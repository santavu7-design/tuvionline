<!DOCTYPE html>
<html>
<head>
    <title>Ki·ªÉm tra t√¨nh tr·∫°ng</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>Ki·ªÉm tra t√¨nh tr·∫°ng Tu Vi App</h1>
    
    <button onclick="checkServer()">1. Ki·ªÉm tra Server</button>
    <button onclick="checkFile()">2. Ki·ªÉm tra File MD</button>
    <button onclick="testFetch()">3. Test Fetch</button>
    <button onclick="testParse()">4. Test Parse</button>
    <button onclick="fullTest()">5. Test To√†n B·ªô</button>
    
    <div id="results"></div>

    <script>
        function addResult(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong>: ${message}`;
            document.getElementById('results').appendChild(div);
        }

        async function checkServer() {
            try {
                const response = await fetch(window.location.href);
                if (response.ok) {
                    addResult('‚úÖ Server ƒëang ch·∫°y b√¨nh th∆∞·ªùng', 'success');
                } else {
                    addResult('‚ùå Server c√≥ v·∫•n ƒë·ªÅ: ' + response.status, 'error');
                }
            } catch (error) {
                addResult('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi server: ' + error.message, 'error');
            }
        }

        async function checkFile() {
            try {
                const response = await fetch('sample_gemini_response.md', { method: 'HEAD' });
                if (response.ok) {
                    addResult('‚úÖ File sample_gemini_response.md t·ªìn t·∫°i', 'success');
                } else {
                    addResult('‚ùå File kh√¥ng t·ªìn t·∫°i: ' + response.status, 'error');
                }
            } catch (error) {
                addResult('‚ùå L·ªói ki·ªÉm tra file: ' + error.message, 'error');
            }
        }

        async function testFetch() {
            try {
                addResult('üîÑ ƒêang t·∫£i file markdown...', 'info');
                const response = await fetch('sample_gemini_response.md');
                if (response.ok) {
                    const text = await response.text();
                    addResult(`‚úÖ T·∫£i file th√†nh c√¥ng! K√≠ch th∆∞·ªõc: ${text.length} k√Ω t·ª±`, 'success');
                    addResult(`üìÑ D√≤ng ƒë·∫ßu: "${text.split('\\n')[0]}"`, 'info');
                } else {
                    addResult('‚ùå L·ªói t·∫£i file: ' + response.status, 'error');
                }
            } catch (error) {
                addResult('‚ùå L·ªói fetch: ' + error.message, 'error');
            }
        }

        function parseMarkdownToData(markdownText) {
            const data = { cungTuVi: {} };
            const lines = markdownText.split('\\n');
            let currentCung = '';
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                if (line.startsWith('## ')) {
                    currentCung = line.substring(3).trim();
                    data.cungTuVi[currentCung] = {
                        diaChi: '', chinhTinh: '', phuTinhTot: '', phuTinhXau: '',
                        phuTinhTrungBinh: '', vongTrangSinh: '', isThan: false
                    };
                }
                
                if (line.includes('ho_ten:')) {
                    data.hoTen = line.split(':')[1]?.trim() || '';
                } else if (line.includes('gioi_tinh:')) {
                    data.gioiTinh = line.split(':')[1]?.trim() || '';
                }
                
                if (currentCung && data.cungTuVi[currentCung]) {
                    const cung = data.cungTuVi[currentCung];
                    if (line.includes('dia_chi:')) {
                        cung.diaChi = line.split(':')[1]?.trim() || '';
                    } else if (line.includes('chinh_tinh:')) {
                        cung.chinhTinh = line.split(':')[1]?.trim() || '';
                    }
                }
            }
            return data;
        }

        async function testParse() {
            try {
                addResult('üîÑ ƒêang test parse markdown...', 'info');
                const response = await fetch('sample_gemini_response.md');
                if (response.ok) {
                    const text = await response.text();
                    const parsed = parseMarkdownToData(text);
                    addResult(`‚úÖ Parse th√†nh c√¥ng! T√¨m th·∫•y ${Object.keys(parsed.cungTuVi).length} cung`, 'success');
                    addResult(`üë§ H·ªç t√™n: ${parsed.hoTen || 'N/A'}`, 'info');
                    addResult(`üéØ Cung ƒë·∫ßu ti√™n: ${Object.keys(parsed.cungTuVi)[0] || 'N/A'}`, 'info');
                } else {
                    addResult('‚ùå Kh√¥ng th·ªÉ t·∫£i file ƒë·ªÉ parse', 'error');
                }
            } catch (error) {
                addResult('‚ùå L·ªói parse: ' + error.message, 'error');
            }
        }

        async function fullTest() {
            addResult('üöÄ B·∫Øt ƒë·∫ßu test to√†n b·ªô...', 'info');
            await checkServer();
            await new Promise(r => setTimeout(r, 500));
            await checkFile();
            await new Promise(r => setTimeout(r, 500));
            await testFetch();
            await new Promise(r => setTimeout(r, 500));
            await testParse();
            addResult('‚úÖ Ho√†n th√†nh test to√†n b·ªô!', 'success');
        }
    </script>
</body>
</html>
